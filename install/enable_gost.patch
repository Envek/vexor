--- ext/openssl/ossl.c
+++ ext/openssl/ossl.c
@@ -1048,6 +1048,7 @@ Init_openssl()
      */
     /* CRYPTO_malloc_init(); */
     /* ENGINE_load_builtin_engines(); */
+    OPENSSL_config(NULL); /* Makes Ruby respect system OpenSSL config */
     OpenSSL_add_ssl_algorithms();
     OpenSSL_add_all_algorithms();
     ERR_load_crypto_strings();
--- ext/openssl/ossl_pkey.c
+++ ext/openssl/ossl_pkey.c
@@ -92,6 +92,7 @@ ossl_pkey_new(EVP_PKEY *pkey)
 	return ossl_dh_new(pkey);
 #endif
 #if !defined(OPENSSL_NO_EC) && (OPENSSL_VERSION_NUMBER >= 0x0090802fL)
+    case NID_id_GostR3410_2001:
     case EVP_PKEY_EC:
 	return ossl_ec_new(pkey);
 #endif
--- ext/openssl/ossl_pkey_ec.c
+++ ext/openssl/ossl_pkey_ec.c
@@ -23,9 +23,6 @@ typedef struct {
 
 #define GetPKeyEC(obj, pkey) do { \
     GetPKey((obj), (pkey)); \
-    if (EVP_PKEY_type((pkey)->type) != EVP_PKEY_EC) { \
-	ossl_raise(rb_eRuntimeError, "THIS IS NOT A EC PKEY!"); \
-    } \
 } while (0)
 
 #define SafeGet_ec_group(obj, group) do { \
@@ -133,9 +130,6 @@ VALUE ossl_ec_new(EVP_PKEY *pkey)
     if (!pkey) {
 	obj = ec_instance(cEC, EC_KEY_new());
     } else {
-	if (EVP_PKEY_type(pkey->type) != EVP_PKEY_EC) {
-	    ossl_raise(rb_eTypeError, "Not a EC key!");
-	}
 	WrapPKey(cEC, obj, pkey);
     }
     if (obj == Qfalse) {
@@ -234,7 +228,6 @@ static VALUE ossl_ec_key_initialize(int argc, VALUE *argv, VALUE self)
 
     if (!NIL_P(group))
         rb_funcall(self, rb_intern("group="), 1, arg);
-
     return self;
 }
 
@@ -1598,7 +1591,9 @@ void Init_ossl_ec()
     rb_define_method(cEC, "public_key", ossl_ec_key_get_public_key, 0);
     rb_define_method(cEC, "public_key=", ossl_ec_key_set_public_key, 1);
     rb_define_method(cEC, "private_key?", ossl_ec_key_is_private_key, 0);
+    rb_define_alias (cEC, "private?", "private_key?"); /* Required by OpenSSL::PKey::PKey.sign */
     rb_define_method(cEC, "public_key?", ossl_ec_key_is_public_key, 0);
+    rb_define_alias (cEC, "public?", "public_key?");
 /*  rb_define_method(cEC, "", ossl_ec_key_get_, 0);
     rb_define_method(cEC, "=", ossl_ec_key_set_ 1);
     set/get enc_flags
